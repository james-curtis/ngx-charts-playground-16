import { Input, ContentChildren, QueryList, ElementRef, Directive, HostBinding } from '@angular/core';
import { SplitAreaDirective } from './split-area.directive';
import { SplitHandleComponent } from './split-handle.component';
import { SplitDirection } from './split-direction.enum';
import { getMinMaxPct } from './get-min-max-pct.util';
import { basisToValue } from './basis-to-value.util';
import { isPercent } from './is-percent.util';
import { resizeAreaBy } from './resize-area-by.util';
export class SplitDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.direction = SplitDirection.Row;
        this.subscriptions = [];
    }
    get rowCss() {
        return this.direction === SplitDirection.Row;
    }
    get columnCss() {
        return this.direction === SplitDirection.Column;
    }
    ngAfterContentInit() {
        this.subscriptions.push(...this.handles.map(d => d.drag.subscribe((ev) => this.onDrag(ev))));
        this.subscriptions.push(...this.handles.map(d => d.dblclick.subscribe(() => this.onDblClick())));
        this.updateHandles();
    }
    ngOnChanges() {
        if (!this.direction) {
            this.direction = SplitDirection.Row;
        }
        this.updateHandles();
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => {
            sub.unsubscribe();
        });
    }
    resize(delta) {
        const basisToPx = (this.rowCss ? this.elementRef.nativeElement.clientWidth : this.elementRef.nativeElement.clientHeight) / 100;
        const areas = this.areas.toArray();
        // for now assuming splitter is after first area
        const [first, ...rest] = areas;
        [first].forEach(area => (delta = resizeAreaBy(area, delta, basisToPx)));
        // delta is distributed left to right
        rest.forEach(area => (delta += resizeAreaBy(area, -delta, basisToPx)));
    }
    updateHandles() {
        if (this.handles) {
            this.handles.forEach(d => (d.direction = this.direction));
        }
    }
    onDblClick() {
        const basisToPx = (this.rowCss ? this.elementRef.nativeElement.clientWidth : this.elementRef.nativeElement.clientHeight) / 100;
        const area = this.areas.first;
        /* istanbul ignore if */
        if (!area)
            return;
        const [grow, shrink, basis] = area.currentFlexParts;
        const isPct = isPercent(basis);
        const basisValue = basisToValue(basis);
        // get basis in px and %
        const basisPx = isPct ? basisValue * basisToPx : basisValue;
        const basisPct = basisPx / basisToPx;
        // get baseBasis in percent
        const baseBasis = area.initialFlexParts[2];
        const baseBasisPct = basisToValue(baseBasis) / (isPercent(baseBasis) ? basisToPx : 1);
        const [minBasisPct, maxBasisPct] = getMinMaxPct(area.minBasis, area.maxBasis, grow, shrink, baseBasisPct, basisToPx);
        // max and min deltas
        const deltaMin = basisPct - minBasisPct;
        const deltaMax = maxBasisPct - basisPct;
        const delta = deltaMin < deltaMax ? deltaMax : -deltaMin;
        const deltaPx = delta * basisToPx;
        this.resize(deltaPx);
    }
    onDrag({ movementX, movementY }) {
        const deltaPx = this.direction === SplitDirection.Row ? movementX : movementY;
        this.resize(deltaPx);
    }
}
SplitDirective.decorators = [
    { type: Directive, args: [{
                exportAs: 'ngxSplit',
                selector: '[ngxSplit]',
                host: {
                    class: 'ngx-split',
                    '[class.row-split]': 'rowCss',
                    '[class.column-split]': 'columnCss',
                    '[style.display]': '"flex"',
                    '[style.height]': '"100%"',
                    '[style.width]': '"100%"'
                }
            },] }
];
SplitDirective.ctorParameters = () => [
    { type: ElementRef }
];
SplitDirective.propDecorators = {
    direction: [{ type: HostBinding, args: ['style.flex-direction',] }, { type: Input, args: ['ngxSplit',] }],
    handles: [{ type: ContentChildren, args: [SplitHandleComponent, { descendants: false },] }],
    areas: [{ type: ContentChildren, args: [SplitAreaDirective, { descendants: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXQuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3dpbWxhbmUvbmd4LXVpL3NyYy9saWIvY29tcG9uZW50cy9zcGxpdC9zcGxpdC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLEtBQUssRUFDTCxlQUFlLEVBRWYsU0FBUyxFQUNULFVBQVUsRUFDVixTQUFTLEVBRVQsV0FBVyxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFlckQsTUFBTSxPQUFPLGNBQWM7SUFxQnpCLFlBQTZCLFVBQXNCO1FBQXRCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFsQm5ELGNBQVMsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDO1FBZ0J2QixrQkFBYSxHQUFtQixFQUFFLENBQUM7SUFFVyxDQUFDO0lBaEJ2RCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxTQUFTLEtBQUssY0FBYyxDQUFDLEdBQUcsQ0FBQztJQUMvQyxDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsU0FBUyxLQUFLLGNBQWMsQ0FBQyxNQUFNLENBQUM7SUFDbEQsQ0FBQztJQVlELGtCQUFrQjtRQUNoQixJQUFJLENB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Q0FBQyxTQUFTLENBQUM7UUFDOUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2QixDQUFDOzs7WUFySEYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxVQUFVO2dCQUNwQixRQUFRLEVBQUUsWUFBWTtnQkFDdEIsSUFBSSxFQUFFO29CQUNKLEtBQUssRUFBRSxXQUFXO29CQUNsQixtQkFBbUIsRUFBRSxRQUFRO29CQUM3QixzQkFBc0IsRUFBRSxXQUFXO29CQUNuQyxpQkFBaUIsRUFBRSxRQUFRO29CQUMzQixnQkFBZ0IsRUFBRSxRQUFRO29CQUMxQixlQUFlLEVBQUUsUUFBUTtpQkFDMUI7YUFDRjs7O1lBM0JDLFVBQVU7Ozt3QkE2QlQsV0FBVyxTQUFDLHNCQUFzQixjQUNsQyxLQUFLLFNBQUMsVUFBVTtzQkFXaEIsZUFBZSxTQUFDLG9CQUFvQixFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRTtvQkFHNUQsZUFBZSxTQUFDLGtCQUFrQixFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIElucHV0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEFmdGVyQ29udGVudEluaXQsXG4gIFF1ZXJ5TGlzdCxcbiAgRWxlbWVudFJlZixcbiAgRGlyZWN0aXZlLFxuICBPbkNoYW5nZXMsXG4gIEhvc3RCaW5kaW5nLFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFNwbGl0QXJlYURpcmVjdGl2ZSB9IGZyb20gJy4vc3BsaXQtYXJlYS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgU3BsaXRIYW5kbGVDb21wb25lbnQgfSBmcm9tICcuL3NwbGl0LWhhbmRsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3BsaXREaXJlY3Rpb24gfSBmcm9tICcuL3NwbGl0LWRpcmVjdGlvbi5lbnVtJztcbmltcG9ydCB7IGdldE1pbk1heFBjdCB9IGZyb20gJy4vZ2V0LW1pbi1tYXgtcGN0LnV0aWwnO1xuaW1wb3J0IHsgYmFzaXNUb1ZhbHVlIH0gZnJvbSAnLi9iYXNpcy10by12YWx1ZS51dGlsJztcbmltcG9ydCB7IGlzUGVyY2VudCB9IGZyb20gJy4vaXMtcGVyY2VudC51dGlsJztcbmltcG9ydCB7IHJlc2l6ZUFyZWFCeSB9IGZyb20gJy4vcmVzaXplLWFyZWEtYnkudXRpbCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL2ludGVybmFsL1N1YnNjcmlwdGlvbic7XG5cbkBEaXJlY3RpdmUoe1xuICBleHBvcnRBczogJ25neFNwbGl0JyxcbiAgc2VsZWN0b3I6ICdbbmd4U3BsaXRdJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbmd4LXNwbGl0JyxcbiAgICAnW2NsYXNzLnJvdy1zcGxpdF0nOiAncm93Q3NzJyxcbiAgICAnW2NsYXNzLmNvbHVtbi1zcGxpdF0nOiAnY29sdW1uQ3NzJyxcbiAgICAnW3N0eWxlLmRpc3BsYXldJzogJ1wiZmxleFwiJyxcbiAgICAnW3N0eWxlLmhlaWdodF0nOiAnXCIxMDAlXCInLFxuICAgICdbc3R5bGUud2lkdGhdJzogJ1wiMTAwJVwiJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIFNwbGl0RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgtZGlyZWN0aW9uJylcbiAgQElucHV0KCduZ3hTcGxpdCcpXG4gIGRpcmVjdGlvbiA9IFNwbGl0RGlyZWN0aW9uLlJvdztcblxuICBnZXQgcm93Q3NzKCkge1xuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gU3BsaXREaXJlY3Rpb24uUm93O1xuICB9XG5cbiAgZ2V0IGNvbHVtbkNzcygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IFNwbGl0RGlyZWN0aW9uLkNvbHVtbjtcbiAgfVxuXG4gIEBDb250ZW50Q2hpbGRyZW4oU3BsaXRIYW5kbGVDb21wb25lbnQsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gIHJlYWRvbmx5IGhhbmRsZXM6IFF1ZXJ5TGlzdDxTcGxpdEhhbmRsZUNvbXBvbmVudD47XG5cbiAgQENvbnRlbnRDaGlsZHJlbihTcGxpdEFyZWFEaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pXG4gIHJlYWRvbmx5IGFyZWFzOiBRdWVyeUxpc3Q8U3BsaXRBcmVhRGlyZWN0aXZlPjtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCguLi50aGlzLmhhbmRsZXMubWFwKGQgPT4gZC5kcmFnLnN1YnNjcmliZSgoZXY6IE1vdXNlRXZlbnQpID0+IHRoaXMub25EcmFnKGV2KSkpKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCguLi50aGlzLmhhbmRsZXMubWFwKGQgPT4gZC5kYmxjbGljay5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkRibENsaWNrKCkpKSk7XG4gICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAoIXRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IFNwbGl0RGlyZWN0aW9uLlJvdztcbiAgICB9XG4gICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXNpemUoZGVsdGE6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGJhc2lzVG9QeCA9XG4gICAgICAodGhpcy5yb3dDc3MgPyB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRXaWR0aCA6IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCkgLyAxMDA7XG5cbiAgICBjb25zdCBhcmVhcyA9IHRoaXMuYXJlYXMudG9BcnJheSgpO1xuXG4gICAgLy8gZm9yIG5vdyBhc3N1bWluZyBzcGxpdHRlciBpcyBhZnRlciBmaXJzdCBhcmVhXG4gICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IGFyZWFzO1xuICAgIFtmaXJzdF0uZm9yRWFjaChhcmVhID0+IChkZWx0YSA9IHJlc2l6ZUFyZWFCeShhcmVhLCBkZWx0YSwgYmFzaXNUb1B4KSkpO1xuXG4gICAgLy8gZGVsdGEgaXMgZGlzdHJpYnV0ZWQgbGVmdCB0byByaWdodFxuICAgIHJlc3QuZm9yRWFjaChhcmVhID0+IChkZWx0YSArPSByZXNpemVBcmVhQnkoYXJlYSwgLWRlbHRhLCBiYXNpc1RvUHgpKSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhhbmRsZXMoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcykge1xuICAgICAgdGhpcy5oYW5kbGVzLmZvckVhY2goZCA9PiAoZC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbikpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25EYmxDbGljaygpOiB2b2lkIHtcbiAgICBjb25zdCBiYXNpc1RvUHggPVxuICAgICAgKHRoaXMucm93Q3NzID8gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50V2lkdGggOiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQpIC8gMTAwO1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuYXJlYXMuZmlyc3Q7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWFyZWEpIHJldHVybjtcblxuICAgIGNvbnN0IFtncm93LCBzaHJpbmssIGJhc2lzXSA9IGFyZWEuY3VycmVudEZsZXhQYXJ0cztcbiAgICBjb25zdCBpc1BjdCA9IGlzUGVyY2VudChiYXNpcyk7XG4gICAgY29uc3QgYmFzaXNWYWx1ZSA9IGJhc2lzVG9WYWx1ZShiYXNpcyk7XG5cbiAgICAvLyBnZXQgYmFzaXMgaW4gcHggYW5kICVcbiAgICBjb25zdCBiYXNpc1B4ID0gaXNQY3QgPyBiYXNpc1ZhbHVlICogYmFzaXNUb1B4IDogYmFzaXNWYWx1ZTtcbiAgICBjb25zdCBiYXNpc1BjdCA9IGJhc2lzUHggLyBiYXNpc1RvUHg7XG5cbiAgICAvLyBnZXQgYmFzZUJhc2lzIGluIHBlcmNlbnRcbiAgICBjb25zdCBiYXNlQmFzaXMgPSBhcmVhLmluaXRpYWxGbGV4UGFydHNbMl07XG4gICAgY29uc3QgYmFzZUJhc2lzUGN0ID0gYmFzaXNUb1ZhbHVlKGJhc2VCYXNpcykgLyAoaXNQZXJjZW50KGJhc2VCYXNpcykgPyBiYXNpc1RvUHggOiAxKTtcblxuICAgIGNvbnN0IFttaW5CYXNpc1BjdCwgbWF4QmFzaXNQY3RdID0gZ2V0TWluTWF4UGN0KFxuICAgICAgYXJlYS5taW5CYXNpcyxcbiAgICAgIGFyZWEubWF4QmFzaXMsXG4gICAgICBncm93LFxuICAgICAgc2hyaW5rLFxuICAgICAgYmFzZUJhc2lzUGN0LFxuICAgICAgYmFzaXNUb1B4XG4gICAgKTtcblxuICAgIC8vIG1heCBhbmQgbWluIGRlbHRhc1xuICAgIGNvbnN0IGRlbHRhTWluID0gYmFzaXNQY3QgLSBtaW5CYXNpc1BjdDtcbiAgICBjb25zdCBkZWx0YU1heCA9IG1heEJhc2lzUGN0IC0gYmFzaXNQY3Q7XG5cbiAgICBjb25zdCBkZWx0YSA9IGRlbHRhTWluIDwgZGVsdGFNYXggPyBkZWx0YU1heCA6IC1kZWx0YU1pbjtcbiAgICBjb25zdCBkZWx0YVB4ID0gZGVsdGEgKiBiYXNpc1RvUHg7XG5cbiAgICB0aGlzLnJlc2l6ZShkZWx0YVB4KTtcbiAgfVxuXG4gIHByaXZhdGUgb25EcmFnKHsgbW92ZW1lbnRYLCBtb3ZlbWVudFkgfTogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGRlbHRhUHggPSB0aGlzLmRpcmVjdGlvbiA9PT0gU3BsaXREaXJlY3Rpb24uUm93ID8gbW92ZW1lbnRYIDogbW92ZW1lbnRZO1xuICAgIHRoaXMucmVzaXplKGRlbHRhUHgpO1xuICB9XG59XG4iXX0=