export const requiredIndicatorIcon = `
  <svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.38411 10L2.19205 9.10616L3.89073 6.2089L1 4.97603L1.44702 3.55822L4.48676 4.32877L4.75497 1H6.21523L6.48344 4.29795L9.55298 3.55822L10 4.97603L7.10927 6.2089L8.77815 9.10616L7.61589 10L5.5 7.34931L3.38411 10Z" fill="#72819F" stroke="#72819F" stroke-width="0.5"/>
  </svg>`;
export const propTypes = ['null', 'string', 'number', 'integer', 'boolean', 'object', 'array'];
const ɵ0 = () => '', ɵ1 = (value) => {
    return typeof value === 'string';
}, ɵ2 = () => 0, ɵ3 = (value) => {
    return typeof value === 'number';
}, ɵ4 = () => 0, ɵ5 = (value) => {
    return typeof value === 'number';
}, ɵ6 = () => true, ɵ7 = (value) => {
    return typeof value === 'boolean';
}, ɵ8 = () => JSON.parse(JSON.stringify({})), ɵ9 = (value) => {
    return typeof value === 'object';
}, ɵ10 = () => JSON.parse(JSON.stringify([])), ɵ11 = (value) => {
    return Array.isArray(value);
}, ɵ12 = () => null, ɵ13 = (value) => {
    // NOTE: because of the way type inference is implemented, we need
    // to check for 'null' AFTER we check for 'object', since
    // typeof null === 'object'
    return value === null;
};
export const jsonSchemaDataTypes = [
    {
        name: 'String',
        defaultValue: ɵ0,
        schema: {
            type: 'string'
        },
        icon: 'field-text',
        matchType: ɵ1
    },
    {
        name: 'Number',
        defaultValue: ɵ2,
        schema: {
            type: 'number'
        },
        icon: 'field-numeric',
        matchType: ɵ3
    },
    {
        name: 'Integer',
        defaultValue: ɵ4,
        schema: {
            type: 'integer'
        },
        icon: 'field-numeric',
        matchType: ɵ5
    },
    {
        name: 'Boolean',
        defaultValue: ɵ6,
        schema: {
            type: 'boolean'
        },
        icon: 'check-square-filled',
        matchType: ɵ7
    },
    {
        name: 'Object',
        defaultValue: ɵ8,
        schema: {
            type: 'object'
        },
        icon: 'reference-tree',
        matchType: ɵ9
    },
    {
        name: 'Array',
        defaultValue: ɵ10,
        schema: {
            type: 'array'
        },
        icon: 'integrations',
        matchType: ɵ11
    },
    {
        name: 'Null',
        defaultValue: ɵ12,
        schema: {
            type: 'null'
        },
        icon: 'disable',
        matchType: ɵ13
    }
];
const ɵ14 = () => '', ɵ15 = () => {
    return false; // needs to be overriden
}, ɵ16 = () => '', ɵ17 = () => {
    return false; // needs to be overriden
}, ɵ18 = () => '', ɵ19 = () => {
    return false; // needs to be overriden
}, ɵ20 = () => '', ɵ21 = () => {
    return false; // needs to be overriden
};
export const jsonSchemaDataFormats = [
    {
        name: 'Date',
        defaultValue: ɵ14,
        schema: {
            type: 'string',
            format: 'date'
        },
        icon: 'field-date',
        matchType: ɵ15
    },
    {
        name: 'Date & Time',
        defaultValue: ɵ16,
        schema: {
            type: 'string',
            format: 'date-time'
        },
        icon: 'field-date',
        matchType: ɵ17
    },
    {
        name: 'Password',
        defaultValue: ɵ18,
        schema: {
            type: 'string',
            format: 'password'
        },
        icon: 'lock',
        matchType: ɵ19
    },
    {
        name: 'Code',
        defaultValue: ɵ20,
        schema: {
            type: 'string',
            format: 'code'
        },
        icon: 'code',
        matchType: ɵ21
    }
];
export const dataTypeMap = {};
for (const dType of [...jsonSchemaDataTypes, ...jsonSchemaDataFormats]) {
    let key = dType.schema.type;
    if (dType.schema.format) {
        key = `${key}=${dType.schema.format}`;
    }
    dataTypeMap[key] = dType;
}
export function createValueForSchema(schema) {
    if (schema.default) {
        return schema.default;
    }
    if (schema.type) {
        return dataTypeMap[schema.type].defaultValue();
    }
}
/**
 * Infers the schema type of the value
 *
 * @param value the value to infer the schema for
 * @param overrides an object with overridden inference functions for various schema types
 * @param allowedTypes the allowed schema types to consider
 */
export function inferType(value, overrides, allowedTypes) {
    if (overrides) {
        for (const typeName in overrides) {
            if (allowedTypes !== undefined && !allowedTypes.includes(typeName)) {
                continue;
            }
            // eslint-disable-next-line
            if (dataTypeMap[typeName] && overrides[typeName](value)) {
                return dataTypeMap[typeName].schema;
            }
        }
    }
    let type;
    for (const typeName in dataTypeMap) {
        if (allowedTypes !== undefined && !allowedTypes.includes(typeName)) {
            continue;
        }
        if (dataTypeMap[typeName].matchType(value)) {
            type = dataTypeMap[typeName].schema;
        }
    }
    if (!type) {
        type = dataTypeMap.object.schema;
    }
    return type;
}
/**
 * Returns the icon for the schema
 */
export function getIcon(schema) {
    let key = schema.type;
    if (schema.format) {
        key = `${key}=${schema.format}`;
    }
    if (dataTypeMap[key]) {
        return dataTypeMap[key].icon;
    }
    return 'integration';
}
/**
 * Returns a string for the schema.$meta.currentType property in the following format:
 * string, string=code, object, etc.
 *
 * @param schema
 */
export function getCurrentType(schema) {
    if (schema.type !== 'string') {
        return schema.type;
    }
    if (schema.format) {
        return `string=${schema.format}`;
    }
    else {
        return 'string';
    }
}
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9, ɵ10, ɵ11, ɵ12, ɵ13, ɵ14, ɵ15, ɵ16, ɵ17, ɵ18, ɵ19, ɵ20, ɵ21 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1lZGl0b3IuaGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvc3dpbWxhbmUvbmd4LXVpL3NyYy9saWIvY29tcG9uZW50cy9qc29uLWVkaXRvci9qc29uLWVkaXRvci5oZWxwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUc7OztTQUc1QixDQUFDO0FBZ0NWLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBYSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1dBS3ZGLEdBQUcsRUFBRSxDQUFDLEVBQUUsT0FLWCxDQUFDLEtBQVUsRUFBVyxFQUFFO0lBQ2pDLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQ25DLENBQUMsT0FJYSxHQUFHLEVBQUUsQ0FBQyxDQUFDLE9BS1YsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNqQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNuQyxDQUFDLE9BSWEsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUtWLENBQUMsS0FBVSxFQUFXLEVBQUU7SUFDakMsT0FBTyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUM7QUFDbkMsQ0FBQyxPQUlhLEdBQUcsRUFBRSxDQUFDLElBQUksT0FLYixDQUFDLEtBQVUsRUFBVyxFQUFFO0lBQ2pDLE9BQU8sT0FBTyxLQUFLLEtBQUssU0FBUyxDQUFDO0FBQ3BDLENBQUMsT0FJYSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsT0FLdkMsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNqQyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNuQyxDQUFDLFFBSWEsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBS3ZDLENBQUMsS0FBVSxFQUFXLEVBQUU7SUFDakMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlCLENBQUMsUUFJYSxHQUFHLEVBQUUsQ0FBQyxJQUFJLFFBS2IsQ0FBQyxLQUFVLEVBQVcsRUFBRTtJQUNqQyxrRUFBa0U7SUFDbEUseURBQXlEO0lBQ3pELDJCQUEyQjtJQUMzQixPQUFPLEtBQUssS0FBSyxJQUFJLENBQUM7QUFDeEIsQ0FBQztBQS9FTCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBeUI7SUFDdkQ7UUFDRSxJQUFJLEVBQUUsUUFBUTtRQUNkLFlBQVksSUFBVTtRQUN0QixNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtTQUNmO1FBQ0QsSUFBSSxFQUFFLFlBQVk7UUFDbEIsU0FBUyxJQUVSO0tBQ0Y7SUFDRDtRQUNFLElBQUksRUFBRSxRQUFRO1FBQ2QsWUFBWSxJQUFTO1FBQ3JCLE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxRQUFRO1NBQ2Y7UUFDRCxJQUFJLEVBQUUsZUFBZTtRQUNyQixTQUFTLElBRVI7S0FDRjtJQUNEO1FBQ0UsSUFBSSxFQUFFLFNBQVM7UUFDZixZQUFZLElBQVM7UUFDckIsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxJQUFJLEVBQUUsZUFBZTtRQUNyQixTQUFTLElBRVI7S0FDRjtJQUNEO1FBQ0UsSUFBSSxFQUFFLFNBQVM7UUFDZixZQUFZLElBQVk7UUFDeEIsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFNBQVM7U0FDaEI7UUFDRCxJQUFJLEVBQUUscUJBQXFCO1FBQzNCLFNBQVMsSUFFUjtLQUNGO0lBQ0Q7UUFDRSxJQUFJLEVBQUUsUUFBUTtRQUNkLFlBQVksSUFBc0M7UUFDbEQsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7U0FDZjtRQUNELElBQUksRUFBRSxnQkFBZ0I7UUFDdEIsU0FBUyxJQUVSO0tBQ0Y7SUFDRDtRQUNFLElBQUksRUFBRSxPQUFPO1FBQ2IsWUFBWSxLQUFzQztRQUNsRCxNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsT0FBTztTQUNkO1FBQ0QsSUFBSSxFQUFFLGNBQWM7UUFDcEIsU0FBUyxLQUVSO0tBQ0Y7SUFDRDtRQUNFLElBQUksRUFBRSxNQUFNO1FBQ1osWUFBWSxLQUFZO1FBQ3hCLE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxNQUFNO1NBQ2I7UUFDRCxJQUFJLEVBQUUsU0FBUztRQUNmLFNBQVMsS0FLUjtLQUNGO0NBQ0YsQ0FBQztZQUtnQixHQUFHLEVBQUUsQ0FBQyxFQUFFLFFBTVgsR0FBWSxFQUFFO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLENBQUMsd0JBQXdCO0FBQ3hDLENBQUMsUUFJYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFFBTVgsR0FBWSxFQUFFO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLENBQUMsd0JBQXdCO0FBQ3hDLENBQUMsUUFJYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFFBTVgsR0FBWSxFQUFFO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLENBQUMsd0JBQXdCO0FBQ3hDLENBQUMsUUFJYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLFFBTVgsR0FBWSxFQUFFO0lBQ3ZCLE9BQU8sS0FBSyxDQUFDLENBQUMsd0JBQXdCO0FBQ3hDLENBQUM7QUEvQ0wsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQXlCO0lBQ3pEO1FBQ0UsSUFBSSxFQUFFLE1BQU07UUFDWixZQUFZLEtBQVU7UUFDdEIsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7WUFDZCxNQUFNLEVBQUUsTUFBTTtTQUNmO1FBQ0QsSUFBSSxFQUFFLFlBQVk7UUFDbEIsU0FBUyxLQUVSO0tBQ0Y7SUFDRDtRQUNFLElBQUksRUFBRSxhQUFhO1FBQ25CLFlBQVksS0FBVTtRQUN0QixNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtZQUNkLE1BQU0sRUFBRSxXQUFXO1NBQ3BCO1FBQ0QsSUFBSSxFQUFFLFlBQVk7UUFDbEIsU0FBUyxLQUVSO0tBQ0Y7SUFDRDtRQUNFLElBQUksRUFBRSxVQUFVO1FBQ2hCLFlBQVksS0FBVTtRQUN0QixNQUFNLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtZQUNkLE1BQU0sRUFBRSxVQUFVO1NBQ25CO1FBQ0QsSUFBSSxFQUFFLE1BQU07UUFDWixTQUFTLEtBRVI7S0FDRjtJQUNEO1FBQ0UsSUFBSSxFQUFFLE1BQU07UUFDWixZQUFZLEtBQVU7UUFDdEIsTUFBTSxFQUFFO1lBQ04sSUFBSSxFQUFFLFFBQVE7WUFDZCxNQUFNLEVBQUUsTUFBTTtTQUNmO1FBQ0QsSUFBSSxFQUFFLE1BQU07UUFDWixTQUFTLEtBRVI7S0FDRjtDQUNGLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxXQUFXLEdBQXdCLEVBQUUsQ0FBQztBQUVuRCxLQUFLLE1BQU0sS0FBSyxJQUFJLENBQUMsR0FBRyxtQkFBbUIsRUFBRSxHQUFHLHFCQUFxQixDQUFDLEVBQUU7SUFDdEUsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDNUIsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUN2QixHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztLQUN2QztJQUVELFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7Q0FDMUI7QUFFRCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsTUFBd0I7SUFDM0QsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1FBQ2xCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztLQUN2QjtJQUNELElBQUksTUFBTSxDQUFDLElBQUksRUFBRTtRQUNmLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFjLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztLQUMxRDtBQUNILENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLEtBQVUsRUFBRSxTQUFlLEVBQUUsWUFBdUI7SUFDNUUsSUFBSSxTQUFTLEVBQUU7UUFDYixLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRTtZQUNoQyxJQUFJLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUNsRSxTQUFTO2FBQ1Y7WUFDRCwyQkFBMkI7WUFDM0IsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN2RCxPQUFPLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUM7YUFDckM7U0FDRjtLQUNGO0lBRUQsSUFBSSxJQUFJLENBQUM7SUFDVCxLQUFLLE1BQU0sUUFBUSxJQUFJLFdBQVcsRUFBRTtRQUNsQyxJQUFJLFlBQVksS0FBSyxTQUFTLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2xFLFNBQVM7U0FDVjtRQUVELElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMxQyxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztTQUNyQztLQUNGO0lBRUQsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULElBQUksR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztLQUNsQztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBQyxNQUF3QjtJQUM5QyxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBYyxDQUFDO0lBQ2hDLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUNqQixHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ2pDO0lBQ0QsSUFBSSxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDcEIsT0FBTyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBQzlCO0lBRUQsT0FBTyxhQUFhLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FBQyxNQUF3QjtJQUNyRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzVCLE9BQU8sTUFBTSxDQUFDLElBQWMsQ0FBQztLQUM5QjtJQUVELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtRQUNqQixPQUFPLFVBQVUsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ2xDO1NBQU07UUFDTCxPQUFPLFFBQVEsQ0FBQztLQUNqQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBKU09OU2NoZW1hNywgSlNPTlNjaGVtYTdUeXBlTmFtZSB9IGZyb20gJ2pzb24tc2NoZW1hJztcblxuZXhwb3J0IGNvbnN0IHJlcXVpcmVkSW5kaWNhdG9ySWNvbiA9IGBcbiAgPHN2ZyB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTFcIiB2aWV3Qm94PVwiMCAwIDExIDExXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgPHBhdGggZD1cIk0zLjM4NDExIDEwTDIuMTkyMDUgOS4xMDYxNkwzLjg5MDczIDYuMjA4OUwxIDQuOTc2MDNMMS40NDcwMiAzLjU1ODIyTDQuNDg2NzYgNC4zMjg3N0w0Ljc1NDk3IDFINi4yMTUyM0w2LjQ4MzQ0IDQuMjk3OTVMOS41NTI5OCAzLjU1ODIyTDEwIDQuOTc2MDNMNy4xMDkyNyA2LjIwODlMOC43NzgxNSA5LjEwNjE2TDcuNjE1ODkgMTBMNS41IDcuMzQ5MzFMMy4zODQxMSAxMFpcIiBmaWxsPVwiIzcyODE5RlwiIHN0cm9rZT1cIiM3MjgxOUZcIiBzdHJva2Utd2lkdGg9XCIwLjVcIi8+XG4gIDwvc3ZnPmA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSlNPTkVkaXRvclNjaGVtYSBleHRlbmRzIEpTT05TY2hlbWE3IHtcbiAgJG1ldGE/OiBhbnk7XG4gIHByb3BlcnRpZXM/OiB7XG4gICAgW2tleTogc3RyaW5nXTogSlNPTkVkaXRvclNjaGVtYTtcbiAgfTtcbiAgcGF0dGVyblByb3BlcnRpZXM/OiB7XG4gICAgW2tleTogc3RyaW5nXTogSlNPTkVkaXRvclNjaGVtYTtcbiAgfTtcbiAgaXRlbXM/OiBKU09ORWRpdG9yU2NoZW1hO1xuICBuYW1lRWRpdGFibGU/OiBib29sZWFuO1xuICBwcm9wZXJ0eU5hbWU/OiBzdHJpbmc7XG4gIGN1cnJlbnRUeXBlPzogSlNPTlNjaGVtYTdUeXBlTmFtZSB8IEpTT05TY2hlbWE3VHlwZU5hbWVbXTtcbiAgaWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcGVydHlJbmRleCBleHRlbmRzIEpTT05FZGl0b3JTY2hlbWEge1xuICBbaWQ6IG51bWJlcl06IEpTT05FZGl0b3JTY2hlbWE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnNvblNjaGVtYURhdGFUeXBlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBkZWZhdWx0VmFsdWU6ICgpID0+IGFueTtcbiAgc2NoZW1hOiB7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIGZvcm1hdD86IHN0cmluZztcbiAgfTtcbiAgaWNvbjogc3RyaW5nO1xuICBtYXRjaFR5cGU6ICh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcHJvcFR5cGVzOiBzdHJpbmdbXSA9IFsnbnVsbCcsICdzdHJpbmcnLCAnbnVtYmVyJywgJ2ludGVnZXInLCAnYm9vbGVhbicsICdvYmplY3QnLCAnYXJyYXknXTtcblxuZXhwb3J0IGNvbnN0IGpzb25TY2hlbWFEYXRhVHlwZXM6IEpzb25TY2hlbWFEYXRhVHlwZVtdID0gW1xuICB7XG4gICAgbmFtZTogJ1N0cmluZycsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJyxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcbiAgICBpY29uOiAnZmllbGQtdGV4dCcsXG4gICAgbWF0Y2hUeXBlOiAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICB9LFxuICB7XG4gICAgbmFtZTogJ051bWJlcicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwLFxuICAgIHNjaGVtYToge1xuICAgICAgdHlwZTogJ251bWJlcidcbiAgICB9LFxuICAgIGljb246ICdmaWVsZC1udW1lcmljJyxcbiAgICBtYXRjaFR5cGU6ICh2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnSW50ZWdlcicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwLFxuICAgIHNjaGVtYToge1xuICAgICAgdHlwZTogJ2ludGVnZXInXG4gICAgfSxcbiAgICBpY29uOiAnZmllbGQtbnVtZXJpYycsXG4gICAgbWF0Y2hUeXBlOiAodmFsdWU6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuICB9LFxuICB7XG4gICAgbmFtZTogJ0Jvb2xlYW4nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gdHJ1ZSxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJ1xuICAgIH0sXG4gICAgaWNvbjogJ2NoZWNrLXNxdWFyZS1maWxsZWQnLFxuICAgIG1hdGNoVHlwZTogKHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnT2JqZWN0JyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoe30pKSxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfSxcbiAgICBpY29uOiAncmVmZXJlbmNlLXRyZWUnLFxuICAgIG1hdGNoVHlwZTogKHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIG5hbWU6ICdBcnJheScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFtdKSksXG4gICAgc2NoZW1hOiB7XG4gICAgICB0eXBlOiAnYXJyYXknXG4gICAgfSxcbiAgICBpY29uOiAnaW50ZWdyYXRpb25zJyxcbiAgICBtYXRjaFR5cGU6ICh2YWx1ZTogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgbmFtZTogJ051bGwnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbCxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdudWxsJ1xuICAgIH0sXG4gICAgaWNvbjogJ2Rpc2FibGUnLCAvLyA/P1xuICAgIG1hdGNoVHlwZTogKHZhbHVlOiBhbnkpOiBib29sZWFuID0+IHtcbiAgICAgIC8vIE5PVEU6IGJlY2F1c2Ugb2YgdGhlIHdheSB0eXBlIGluZmVyZW5jZSBpcyBpbXBsZW1lbnRlZCwgd2UgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgZm9yICdudWxsJyBBRlRFUiB3ZSBjaGVjayBmb3IgJ29iamVjdCcsIHNpbmNlXG4gICAgICAvLyB0eXBlb2YgbnVsbCA9PT0gJ29iamVjdCdcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG4gIH1cbl07XG5cbmV4cG9ydCBjb25zdCBqc29uU2NoZW1hRGF0YUZvcm1hdHM6IEpzb25TY2hlbWFEYXRhVHlwZVtdID0gW1xuICB7XG4gICAgbmFtZTogJ0RhdGUnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJycsXG4gICAgc2NoZW1hOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ2RhdGUnXG4gICAgfSxcbiAgICBpY29uOiAnZmllbGQtZGF0ZScsXG4gICAgbWF0Y2hUeXBlOiAoKTogYm9vbGVhbiA9PiB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIG92ZXJyaWRlblxuICAgIH1cbiAgfSxcbiAge1xuICAgIG5hbWU6ICdEYXRlICYgVGltZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJyxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnZGF0ZS10aW1lJ1xuICAgIH0sXG4gICAgaWNvbjogJ2ZpZWxkLWRhdGUnLFxuICAgIG1hdGNoVHlwZTogKCk6IGJvb2xlYW4gPT4ge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBuZWVkcyB0byBiZSBvdmVycmlkZW5cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnUGFzc3dvcmQnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJycsXG4gICAgc2NoZW1hOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ3Bhc3N3b3JkJ1xuICAgIH0sXG4gICAgaWNvbjogJ2xvY2snLFxuICAgIG1hdGNoVHlwZTogKCk6IGJvb2xlYW4gPT4ge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBuZWVkcyB0byBiZSBvdmVycmlkZW5cbiAgICB9XG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnQ29kZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAnJyxcbiAgICBzY2hlbWE6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnY29kZSdcbiAgICB9LFxuICAgIGljb246ICdjb2RlJyxcbiAgICBtYXRjaFR5cGU6ICgpOiBib29sZWFuID0+IHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgb3ZlcnJpZGVuXG4gICAgfVxuICB9XG5dO1xuXG5leHBvcnQgY29uc3QgZGF0YVR5cGVNYXA6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblxuZm9yIChjb25zdCBkVHlwZSBvZiBbLi4uanNvblNjaGVtYURhdGFUeXBlcywgLi4uanNvblNjaGVtYURhdGFGb3JtYXRzXSkge1xuICBsZXQga2V5ID0gZFR5cGUuc2NoZW1hLnR5cGU7XG4gIGlmIChkVHlwZS5zY2hlbWEuZm9ybWF0KSB7XG4gICAga2V5ID0gYCR7a2V5fT0ke2RUeXBlLnNjaGVtYS5mb3JtYXR9YDtcbiAgfVxuXG4gIGRhdGFUeXBlTWFwW2tleV0gPSBkVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZhbHVlRm9yU2NoZW1hKHNjaGVtYTogSlNPTkVkaXRvclNjaGVtYSk6IGFueSB7XG4gIGlmIChzY2hlbWEuZGVmYXVsdCkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUpIHtcbiAgICByZXR1cm4gZGF0YVR5cGVNYXBbc2NoZW1hLnR5cGUgYXMgc3RyaW5nXS5kZWZhdWx0VmFsdWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEluZmVycyB0aGUgc2NoZW1hIHR5cGUgb2YgdGhlIHZhbHVlXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBpbmZlciB0aGUgc2NoZW1hIGZvclxuICogQHBhcmFtIG92ZXJyaWRlcyBhbiBvYmplY3Qgd2l0aCBvdmVycmlkZGVuIGluZmVyZW5jZSBmdW5jdGlvbnMgZm9yIHZhcmlvdXMgc2NoZW1hIHR5cGVzXG4gKiBAcGFyYW0gYWxsb3dlZFR5cGVzIHRoZSBhbGxvd2VkIHNjaGVtYSB0eXBlcyB0byBjb25zaWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mZXJUeXBlKHZhbHVlOiBhbnksIG92ZXJyaWRlcz86IGFueSwgYWxsb3dlZFR5cGVzPzogc3RyaW5nW10pOiBhbnkge1xuICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgZm9yIChjb25zdCB0eXBlTmFtZSBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGlmIChhbGxvd2VkVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgaWYgKGRhdGFUeXBlTWFwW3R5cGVOYW1lXSAmJiBvdmVycmlkZXNbdHlwZU5hbWVdKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGF0YVR5cGVNYXBbdHlwZU5hbWVdLnNjaGVtYTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdHlwZTtcbiAgZm9yIChjb25zdCB0eXBlTmFtZSBpbiBkYXRhVHlwZU1hcCkge1xuICAgIGlmIChhbGxvd2VkVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFUeXBlTWFwW3R5cGVOYW1lXS5tYXRjaFR5cGUodmFsdWUpKSB7XG4gICAgICB0eXBlID0gZGF0YVR5cGVNYXBbdHlwZU5hbWVdLnNjaGVtYTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0eXBlID0gZGF0YVR5cGVNYXAub2JqZWN0LnNjaGVtYTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpY29uIGZvciB0aGUgc2NoZW1hXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJY29uKHNjaGVtYTogSlNPTkVkaXRvclNjaGVtYSk6IHN0cmluZyB7XG4gIGxldCBrZXkgPSBzY2hlbWEudHlwZSBhcyBzdHJpbmc7XG4gIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAga2V5ID0gYCR7a2V5fT0ke3NjaGVtYS5mb3JtYXR9YDtcbiAgfVxuICBpZiAoZGF0YVR5cGVNYXBba2V5XSkge1xuICAgIHJldHVybiBkYXRhVHlwZU1hcFtrZXldLmljb247XG4gIH1cblxuICByZXR1cm4gJ2ludGVncmF0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGZvciB0aGUgc2NoZW1hLiRtZXRhLmN1cnJlbnRUeXBlIHByb3BlcnR5IGluIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICogc3RyaW5nLCBzdHJpbmc9Y29kZSwgb2JqZWN0LCBldGMuXG4gKlxuICogQHBhcmFtIHNjaGVtYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFR5cGUoc2NoZW1hOiBKU09ORWRpdG9yU2NoZW1hKTogc3RyaW5nIHtcbiAgaWYgKHNjaGVtYS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzY2hlbWEudHlwZSBhcyBzdHJpbmc7XG4gIH1cblxuICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgIHJldHVybiBgc3RyaW5nPSR7c2NoZW1hLmZvcm1hdH1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxufVxuIl19